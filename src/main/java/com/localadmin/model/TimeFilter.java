/*
 * rest-api
 * An api to fetch manipulate and enter data to the Local Admin service. All Responses can be done with JSON and XML where JSON is the default. You can change the response by setting the content-type header. The downside of our XML is that we do not provide XLS for the Responses
 *
 * OpenAPI spec version: 1.1.0
 * Contact: nbrugger@student.tgm.ac.at
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.localadmin.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.io.Serializable;
/**
 * A Filter to only get a certain range of results between the time frame
 */
@Schema(description = "A Filter to only get a certain range of results between the time frame")

public class TimeFilter implements Serializable{
  private static final long serialVersionUID = 1L;
  @SerializedName("from")
  private LocalDate from = null;

  @SerializedName("to")
  private LocalDate to = null;

  @SerializedName("whitelist")
  private List<LocalDate> whitelist = null;

  public TimeFilter from(LocalDate from) {
    this.from = from;
    return this;
  }

   /**
   * The start of the time frame
   * @return from
  **/
  @Schema(description = "The start of the time frame")
  public LocalDate getFrom() {
    return from;
  }

  public void setFrom(LocalDate from) {
    this.from = from;
  }

  public TimeFilter to(LocalDate to) {
    this.to = to;
    return this;
  }

   /**
   * the end of the time frame
   * @return to
  **/
  @Schema(description = "the end of the time frame")
  public LocalDate getTo() {
    return to;
  }

  public void setTo(LocalDate to) {
    this.to = to;
  }

  public TimeFilter whitelist(List<LocalDate> whitelist) {
    this.whitelist = whitelist;
    return this;
  }

  public TimeFilter addWhitelistItem(LocalDate whitelistItem) {
    if (this.whitelist == null) {
      this.whitelist = new ArrayList<>();
    }
    this.whitelist.add(whitelistItem);
    return this;
  }

   /**
   * Get whitelist
   * @return whitelist
  **/
  @Schema(description = "")
  public List<LocalDate> getWhitelist() {
    return whitelist;
  }

  public void setWhitelist(List<LocalDate> whitelist) {
    this.whitelist = whitelist;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TimeFilter timeFilter = (TimeFilter) o;
    return Objects.equals(this.from, timeFilter.from) &&
        Objects.equals(this.to, timeFilter.to) &&
        Objects.equals(this.whitelist, timeFilter.whitelist);
  }

  @Override
  public int hashCode() {
    return Objects.hash(from, to, whitelist);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TimeFilter {\n");
    
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    whitelist: ").append(toIndentedString(whitelist)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
