/*
 * rest-api
 * An api to fetch manipulate and enter data to the Local Admin service. All Responses can be done with JSON and XML where JSON is the default. You can change the response by setting the content-type header. The downside of our XML is that we do not provide XLS for the Responses
 *
 * OpenAPI spec version: 1.1.0
 * Contact: nbrugger@student.tgm.ac.at
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.threeten.bp.LocalDate;
/**
 * A Filter to only get a certain range of results between the time frame
 */
@Schema(description = "A Filter to only get a certain range of results between the time frame")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2019-11-20T15:33:44.001Z[GMT]")
public class TimeFilter1 {
  @SerializedName("from")
  private LocalDate from = null;

  @SerializedName("to")
  private LocalDate to = null;

  @SerializedName("whitelist")
  private List<LocalDate> whitelist = null;

  public TimeFilter1 from(LocalDate from) {
    this.from = from;
    return this;
  }

   /**
   * The start of the time frame
   * @return from
  **/
  @Schema(description = "The start of the time frame")
  public LocalDate getFrom() {
    return from;
  }

  public void setFrom(LocalDate from) {
    this.from = from;
  }

  public TimeFilter1 to(LocalDate to) {
    this.to = to;
    return this;
  }

   /**
   * the end of the time frame
   * @return to
  **/
  @Schema(description = "the end of the time frame")
  public LocalDate getTo() {
    return to;
  }

  public void setTo(LocalDate to) {
    this.to = to;
  }

  public TimeFilter1 whitelist(List<LocalDate> whitelist) {
    this.whitelist = whitelist;
    return this;
  }

  public TimeFilter1 addWhitelistItem(LocalDate whitelistItem) {
    if (this.whitelist == null) {
      this.whitelist = new ArrayList<LocalDate>();
    }
    this.whitelist.add(whitelistItem);
    return this;
  }

   /**
   * Get whitelist
   * @return whitelist
  **/
  @Schema(description = "")
  public List<LocalDate> getWhitelist() {
    return whitelist;
  }

  public void setWhitelist(List<LocalDate> whitelist) {
    this.whitelist = whitelist;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TimeFilter1 timeFilter1 = (TimeFilter1) o;
    return Objects.equals(this.from, timeFilter1.from) &&
        Objects.equals(this.to, timeFilter1.to) &&
        Objects.equals(this.whitelist, timeFilter1.whitelist);
  }

  @Override
  public int hashCode() {
    return Objects.hash(from, to, whitelist);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TimeFilter1 {\n");
    
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    whitelist: ").append(toIndentedString(whitelist)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
